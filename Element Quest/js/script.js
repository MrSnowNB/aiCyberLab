// js/script.js

// --- DATA ---
const elementsData = [ /* ... All 54 elements ... */ ];
const elementCategories = { /* ... */ };
const gameZones = { /* ... */ };
let currentZoneKey = "all";
let learningContent = {};

// --- DOM ELEMENT REFERENCES ---
// ... (All DOM refs from the previous fully working version) ...
const periodicTableContainer = document.getElementById("periodic-table-container");
const elementInfoContainer = document.getElementById("element-info-container");
const elementInfoTitle = document.getElementById("element-info-title");
const elementDetailsContainer = document.getElementById("element-details");
const d3AtomModelContainer = document.getElementById("d3-atom-model-container");
const atomDiagramPlaceholder = document.getElementById("atom-diagram-placeholder");
const atomDiagramTitle = document.getElementById("atom-diagram-title");
const legendContentDiv = document.getElementById("legend-content");
const gameSelectionContainer = document.getElementById("game-selection-container");
const zoneButtonsContainer = document.getElementById("zone-buttons-container");
const zoneHighlightToggle = document.getElementById("zone-highlight-toggle");
const particlePinpointSelectBtn = document.getElementById("select-particle-pinpoint-btn");
const propertyProfilerSelectBtn = document.getElementById("select-property-profiler-btn");
const elementSleuthSelectBtn = document.getElementById("select-element-sleuth-btn");
const currentZoneNameSpan = document.getElementById("current-zone-name");
const gameControlsContainer = document.getElementById("game-controls-container");
const currentChallengeTitle = document.getElementById("current-challenge-title");
const startChallengeBtn = document.getElementById("start-challenge-btn");
const scoreValueSpan = document.getElementById("score-value");
const attemptsValueSpan = document.getElementById("attempts-value");
const maxAttemptsSpan = document.getElementById("max-attempts-value");
const gameInstructionsP = document.getElementById("game-instructions");
const particlePinpointUI = document.getElementById("particle-pinpoint-ui");
const propertyProfilerUI = document.getElementById("property-profiler-ui");
const elementSleuthUI = document.getElementById("element-sleuth-ui");
const propertyQuestionText = document.getElementById("property-question-text");
const mcqOptionsContainer = document.getElementById("mcq-options-container");
const protonInput = document.getElementById("proton-input");
const neutronInput = document.getElementById("neutron-input");
const electronInput = document.getElementById("electron-input");
const gameActionContainer = document.getElementById("game-action-container");
const checkAnswerBtn = document.getElementById("check-answer-btn");
const feedbackMessageDiv = document.getElementById("feedback-message");
const hintExplanationArea = document.getElementById("hint-explanation-area");
const hintExplanationText = document.getElementById("hint-explanation-text");
const clueDisplayArea = document.getElementById("clue-display-area");
const clueListUl = document.getElementById("clue-list");
const revealNextClueBtn = document.getElementById("reveal-next-clue-btn");
const clueCountCurrentSpan = document.getElementById("clue-count-current");
const clueCountTotalSpan = document.getElementById("clue-count-total");
const sleuthGuessesValueSpan = document.getElementById("sleuth-guesses-value");
const sessionSummaryContainer = document.getElementById("session-summary-container");
const summaryScoreSpan = document.getElementById("summary-score");
const summaryAccuracySpan = document.getElementById("summary-accuracy");
const summaryCorrectSpan = document.getElementById("summary-correct");
const summaryTotalPlayedSpan = document.getElementById("summary-total-played");
const summaryPlayAgainBtn = document.getElementById("summary-play-again-btn");
const summaryNewSettingsBtn = document.getElementById("summary-new-settings-btn");


// --- D3 & SVG CONSTANTS --- (Identical)
// --- GAME STATE & CONSTANTS --- (Identical)
let currentChallengeElementData = null;
let d3Svg = null;
let nucleonSimulation = null;
let score = 0;
let attemptsForCurrentQuestion = 0;
const MAX_ATTEMPTS_PER_QUESTION = 3;
const POINTS_PER_CORRECT_ANSWER = 10;
let currentGameMode = null;
let gameActive = false;
let questionAnswered = false;
let currentQuestionDetails = {};
let selectedMCQAnswer = null;
let isZoneHighlightingActive = true;
let targetElementSleuth = null;
let revealedCluesSleuth = []; // Stores clue OBJECTS that have been revealed
let potentialCluesSleuth = [];
let currentClueIndexSleuth = 0;
const MAX_CLUES_SLEUTH = 5;
let sleuthGuessesRemaining = 3;
const MAX_GUESSES_SLEUTH_ROUND = 3;
let questionsPlayedThisSession = 0;
let correctAnswersThisSession = 0;
const MAX_QUESTIONS_PER_SESSION = 5;

// --- CORE FUNCTIONS ---
function calculateSubatomicParticles(elementData) { if (!elementData) return { protons: 0, neutrons: 0, electrons: 0, error: true }; const protons = elementData.atomicNumber; const electrons = elementData.atomicNumber; const roundedMassNumber = Math.round(elementData.massNumber); let neutrons = roundedMassNumber - protons; if (neutrons < 0) neutrons = 0; return { protons, neutrons, electrons }; }
function displayElementInfo(elementData, revealAll = false) { if (!elementData) { elementDetailsContainer.innerHTML = '<p>No element data to display.</p>'; return; } const particles = calculateSubatomicParticles(elementData); let particleCountsHTML = ''; let infoTitleText = `Details for: ${elementData.name}`; if (revealAll) { particleCountsHTML = ` <div class="subatomic-counts revealed"> <h4>Subatomic Particles:</h4> <p><strong>Protons:</strong> ${particles.protons}</p> <p><strong>Neutrons:</strong> ${particles.neutrons}</p> <p><strong>Electrons:</strong> ${particles.electrons}</p> </div> `; } else if (gameActive && currentGameMode === 'particle-pinpoint') { particleCountsHTML = `<div class="subatomic-counts hidden-counts"><p><em>Correctly identify the particles to see these details!</em></p></div>`; infoTitleText = "Identify the Element's Particles!"; } else if (gameActive && currentGameMode === 'property-profiler') { particleCountsHTML = ` <div class="subatomic-counts revealed"> <h4>Subatomic Particles (Reference):</h4> <p><strong>Protons:</strong> ${particles.protons}</p> <p><strong>Neutrons:</strong> ${particles.neutrons}</p> <p><strong>Electrons:</strong> ${particles.electrons}</p> </div> `; infoTitleText = `Profiling: ${elementData.name}`; } else if (gameActive && currentGameMode === 'element-sleuth' && !revealAll) { particleCountsHTML = `<div class="subatomic-counts hidden-counts"><p><em>Identify the element to see its full details!</em></p></div>`; infoTitleText = "Mystery Element Profile"; } else { particleCountsHTML = `<div class="subatomic-counts hidden-counts"><p><em>Particle counts hidden.</em></p></div>`; } elementInfoTitle.textContent = infoTitleText; const categoryInfo = elementCategories[elementData.category] || elementCategories["unknown"]; const infoHTML = ` <h3>${elementData.name} (${elementData.symbol})</h3> <p><strong>Atomic Number:</strong> ${elementData.atomicNumber}</p> <p><strong>Symbol:</strong> ${elementData.symbol}</p> <p><strong>Name:</strong> ${elementData.name}</p> <p><strong>Atomic Mass (approx.):</strong> ${elementData.massNumber.toFixed(3)}</p> <p><strong>Group:</strong> ${elementData.group}</p> <p><strong>Period:</strong> ${elementData.period}</p> <p><strong>Category:</strong> <span style="color:${categoryInfo.color}; font-weight:bold;">${categoryInfo.name}</span></p> ${particleCountsHTML} `; elementDetailsContainer.innerHTML = infoHTML; elementInfoContainer.classList.toggle('game-mode-hidden', gameActive && !revealAll && (currentGameMode === 'particle-pinpoint' || currentGameMode === 'element-sleuth')); }
function initializeD3Canvas() { if (!d3Svg) { d3Svg = d3.select("#d3-atom-model-container").append("svg").attr("width", D3_SVG_WIDTH).attr("height", D3_SVG_HEIGHT).attr("viewBox", `0 0 ${D3_SVG_WIDTH} ${D3_SVG_HEIGHT}`); d3Svg.append("g").attr("class", "shells-group"); d3Svg.append("g").attr("class", "nucleus-boundary-group"); d3Svg.append("g").attr("class", "nucleons-group"); d3Svg.append("g").attr("class", "electrons-group"); } d3Svg.select(".shells-group").selectAll("*").remove(); d3Svg.select(".nucleus-boundary-group").selectAll("*").remove(); d3Svg.select(".nucleons-group").selectAll("*").remove(); d3Svg.select(".electrons-group").selectAll("*").remove(); }
function nucleonDragStarted(event, d) { if (!event.active && nucleonSimulation) nucleonSimulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; d3.select(this).raise().style("cursor", "grabbing");} function nucleonDragged(event, d) { d.fx = event.x; d.fy = event.y; } function nucleonDragEnded(event, d) { if (!event.active && nucleonSimulation) nucleonSimulation.alphaTarget(0); d.fx = null; d.fy = null; d3.select(this).style("cursor", "grab");} function electronDragStarted(event, d) { d3.select(this).raise().style("cursor", "grabbing");} function electronDragged(event, d) { const draggedElectronGroup = d3.select(this); draggedElectronGroup.attr("transform", `translate(${event.x},${event.y})`);} function electronDragEnded(event, d) { const draggedElectronGroup = d3.select(this); draggedElectronGroup.style("cursor", "grab"); const originalX = D3_SVG_CENTER_X + d.shellRadius * Math.cos(d.angleDeg * Math.PI / 180); const originalY = D3_SVG_CENTER_Y + d.shellRadius * Math.sin(d.angleDeg * Math.PI / 180); draggedElectronGroup.transition().duration(300).attr("transform", `translate(${originalX},${originalY})`);}
function drawAtomWithD3(particles) { initializeD3Canvas(); d3Svg.select(".nucleus-boundary-group").append("circle").attr("cx", D3_SVG_CENTER_X).attr("cy", D3_SVG_CENTER_Y).attr("r", NUCLEUS_DISPLAY_RADIUS).attr("class", "nucleus-boundary-svg"); let nucleonsData = []; const initialScatterRadius = NUCLEON_PACKING_EFFECTIVE_RADIUS * 0.5; for (let i = 0; i < particles.protons; i++) { const angle = Math.random() * 2 * Math.PI; const radius = Math.random() * initialScatterRadius; nucleonsData.push({ type: 'proton', id: `p${i}`, x: D3_SVG_CENTER_X + radius * Math.cos(angle), y: D3_SVG_CENTER_Y + radius * Math.sin(angle) }); } for (let i = 0; i < particles.neutrons; i++) { const angle = Math.random() * 2 * Math.PI; const radius = Math.random() * initialScatterRadius; nucleonsData.push({ type: 'neutron', id: `n${i}`, x: D3_SVG_CENTER_X + radius * Math.cos(angle), y: D3_SVG_CENTER_Y + radius * Math.sin(angle) }); } if (nucleonSimulation) { nucleonSimulation.stop(); } const nucleonGroups = d3Svg.select(".nucleons-group").selectAll("g.nucleon").data(nucleonsData, d => d.id).join("g").attr("class", d => `nucleon ${d.type}-group`).attr("transform", d => `translate(${d.x},${d.y})`).style("cursor", "grab").call(d3.drag().on("start", nucleonDragStarted).on("drag", nucleonDragged).on("end", nucleonDragEnded)); nucleonGroups.append("circle").attr("r", PARTICLE_RADIUS); nucleonGroups.filter(d => d.type === 'proton').append("text").attr("class", "particle-charge-text").text("+"); if (nucleonsData.length > 0) { nucleonSimulation = d3.forceSimulation(nucleonsData).force("collide", d3.forceCollide(PARTICLE_RADIUS + 0.5).strength(0.8).iterations(5)).force("center", d3.forceCenter(D3_SVG_CENTER_X, D3_SVG_CENTER_Y).strength(0.008)).force("boundary", (alpha) => { for (const node of nucleonsData) { const r = Math.sqrt((node.x - D3_SVG_CENTER_X)**2 + (node.y - D3_SVG_CENTER_Y)**2); if (r > NUCLEON_PACKING_EFFECTIVE_RADIUS) { const angle = Math.atan2(node.y - D3_SVG_CENTER_Y, node.x - D3_SVG_CENTER_X); node.x = D3_SVG_CENTER_X + NUCLEON_PACKING_EFFECTIVE_RADIUS * Math.cos(angle); node.y = D3_SVG_CENTER_Y + NUCLEON_PACKING_EFFECTIVE_RADIUS * Math.sin(angle); node.vx *= 0.05; node.vy *= 0.05;}}}).on("tick", () => { nucleonGroups.attr("transform", d => `translate(${d.x},${d.y})`); }); } let electronsToPlace = particles.electrons; let shellNumber = 1; const shellCapacities = [2, 8, 18, 32]; const shellsGroup = d3Svg.select(".shells-group"); const electronsGroup = d3Svg.select(".electrons-group"); while (electronsToPlace > 0 && shellNumber <= 4) { const shellRadius = FIRST_SHELL_RADIUS + (shellNumber - 1) * SHELL_INCREMENT_RADIUS; if (shellRadius + PARTICLE_RADIUS > D3_SVG_WIDTH / 2 - 5) break; shellsGroup.append("circle").attr("cx", D3_SVG_CENTER_X).attr("cy", D3_SVG_CENTER_Y).attr("r", shellRadius).attr("class", "electron-shell-svg"); const electronsInThisShell = Math.min(electronsToPlace, shellCapacities[shellNumber - 1] || electronsToPlace); if (electronsInThisShell === 0 && electronsToPlace > 0 && shellNumber < shellCapacities.length) { shellNumber++; continue; } if (electronsInThisShell === 0) break; let electronDataForShell = []; for (let i = 0; i < electronsInThisShell; i++) { const angleDeg = (i / electronsInThisShell) * 360 - 90; electronDataForShell.push({ id: `e-s${shellNumber}-i${i}`, angleDeg: angleDeg, shellRadius: shellRadius }); } const electronParticleGroups = electronsGroup.selectAll(`g.electron-group-s${shellNumber}`).data(electronDataForShell, d => d.id).join("g").attr("class", `electron-group electron-group-s${shellNumber}`).style("cursor", "grab").attr("transform", d => { const x = D3_SVG_CENTER_X + d.shellRadius * Math.cos(d.angleDeg * Math.PI / 180); const y = D3_SVG_CENTER_Y + d.shellRadius * Math.sin(d.angleDeg * Math.PI / 180); return `translate(${x},${y})`; }).call(d3.drag().on("start", electronDragStarted).on("drag", electronDragged).on("end", electronDragEnded)); electronParticleGroups.append("circle").attr("r", PARTICLE_RADIUS); electronParticleGroups.append("text").attr("class", "particle-charge-text").text("-"); electronsToPlace -= electronsInThisShell; shellNumber++; } }
function showAtomModelForChallenge(elementDataForModel) { if (!elementDataForModel) { d3AtomModelContainer.style.display = 'none'; atomDiagramPlaceholder.style.display = 'block'; atomDiagramPlaceholder.textContent = "Error: No element data for atom model."; if (nucleonSimulation) nucleonSimulation.nodes([]).alpha(1).stop(); return; } atomDiagramTitle.textContent = `Atom Diagram: ${elementDataForModel.name} (${elementDataForModel.symbol})`; d3AtomModelContainer.style.display = 'block'; atomDiagramPlaceholder.style.display = 'none'; const particles = calculateSubatomicParticles(elementDataForModel); if (particles.error) { atomDiagramPlaceholder.textContent = "Error loading atom model."; atomDiagramPlaceholder.style.display = 'block'; d3AtomModelContainer.style.display = 'none'; return; } drawAtomWithD3(particles); }
function updateGameStatusDisplay() { scoreValueSpan.textContent = score; if (currentGameMode === 'element-sleuth') { attemptsValueSpan.textContent = sleuthGuessesRemaining; maxAttemptsSpan.textContent = MAX_GUESSES_SLEUTH_ROUND; clueCountTotalSpan.textContent = Math.min(MAX_CLUES_SLEUTH, potentialCluesSleuth.length || MAX_CLUES_SLEUTH); clueCountCurrentSpan.textContent = revealedCluesSleuth.length; } else { attemptsValueSpan.textContent = attemptsForCurrentQuestion; maxAttemptsSpan.textContent = MAX_ATTEMPTS_PER_QUESTION; } currentZoneNameSpan.textContent = gameZones[currentZoneKey]?.name || "Unknown Zone"; }
function getElementsForCurrentZone() { const zone = gameZones[currentZoneKey]; if (!zone) { console.warn(`Zone key "${currentZoneKey}" not found. Defaulting to all elements.`); return elementsData; } if (zone.elementAtomicNumbers === null) { return elementsData; } if (zone.elementAtomicNumbers) { return elementsData.filter(el => zone.elementAtomicNumbers.includes(el.atomicNumber)); } if (zone.categories) { return elementsData.filter(el => zone.categories.includes(el.category)); } if (zone.customFilter && typeof zone.customFilter === 'function') { return elementsData.filter(zone.customFilter); } console.warn(`Zone "${zone.name}" has no valid filter criteria. Defaulting to all elements.`); return elementsData; }
function selectRandomElementForChallenge() { const availableElements = getElementsForCurrentZone(); if (availableElements.length === 0) { console.error(`CRITICAL: No elements found for zone '${currentZoneKey}'. Please check zone definitions and element data categories.`); console.log("Current zone object:", gameZones[currentZoneKey]); console.log("First few elements from elementsData to check categories:", elementsData.slice(0,5).map(el => ({name: el.name, category: el.category }))); console.warn("Falling back to 'all' zone to select an element."); const allElements = elementsData; if (allElements.length === 0) { console.error("CRITICAL: elementsData array is empty. Cannot select any element."); gameInstructionsP.textContent = "Error: No element data loaded!"; return null; } return allElements[Math.floor(Math.random() * allElements.length)]; } const randomIndex = Math.floor(Math.random() * availableElements.length); return availableElements[randomIndex]; }
function setupParticlePinpointChallenge() { currentChallengeTitle.textContent = "Particle Pinpoint Challenge"; gameInstructionsP.textContent = `Identify the P, N, E for ${currentChallengeElementData.name}.`; particlePinpointUI.style.display = 'block'; propertyProfilerUI.style.display = 'none'; elementSleuthUI.style.display = 'none'; showAtomModelForChallenge(currentChallengeElementData); displayElementInfo(currentChallengeElementData, false); [protonInput, neutronInput, electronInput].forEach(input => { if (input) { input.value = ''; input.classList.remove('input-error', 'input-correct'); input.disabled = false; } }); gameActionContainer.style.display = 'block'; checkAnswerBtn.style.display = 'block'; }
function generateMCQOptions(correctAnswer, propertyType, element) { let options = new Set(); let correctAnswerValue = correctAnswer; if (propertyType === 'category') { options.add(correctAnswerValue); let distractors = Object.keys(elementCategories).filter(catKey => catKey !== correctAnswerValue && catKey !== "unknown"); distractors.sort(() => 0.5 - Math.random()); while (options.size < 4 && distractors.length > 0) { options.add(distractors.shift()); } return Array.from(options).map(optValue => ({ text: elementCategories[optValue]?.name || optValue, value: optValue.toString() })).sort(() => 0.5 - Math.random()); } else if (propertyType === 'group' || propertyType === 'period' || propertyType === 'valenceElectrons') { options.add(correctAnswerValue.toString()); let allPossibleValues = []; if (propertyType === 'valenceElectrons') { allPossibleValues = ["1", "2", "3", "4", "5", "6", "7", "8"]; } else { allPossibleValues = [...new Set(elementsData.map(el => el[propertyType].toString()))].sort((a, b) => parseInt(a) - parseInt(b)); } let distractors = allPossibleValues.filter(valStr => valStr !== correctAnswerValue.toString()); distractors.sort(() => 0.5 - Math.random()); while (options.size < 4 && distractors.length > 0) { options.add(distractors.shift()); } return Array.from(options).map(optValue => { let textToShow = ""; if (propertyType === 'group') textToShow = `Group ${optValue}`; else if (propertyType === 'period') textToShow = `Period ${optValue}`; else if (propertyType === 'valenceElectrons') textToShow = `${optValue} valence electron(s)`; return { text: textToShow, value: optValue.toString() }; }).sort(() => 0.5 - Math.random()); } else if (propertyType === 'standardState') { options.add(correctAnswerValue); const states = ["Solid", "Liquid", "Gas"]; let distractors = states.filter(s => s !== correctAnswerValue); distractors.sort(() => 0.5 - Math.random()); while (options.size < 3 && distractors.length > 0) { options.add(distractors.shift()); } return Array.from(options).map(optValue => ({ text: optValue, value: optValue.toString() })).sort(() => 0.5 - Math.random()); } console.warn("Unhandled property type for MCQ generation in generateMCQOptions:", propertyType); options.add(correctAnswerValue.toString()); return Array.from(options).map(optValue => ({ text: optValue, value: optValue.toString()})); }
function setupPropertyProfilerChallenge() { currentChallengeTitle.textContent = "Property Profiler Challenge"; particlePinpointUI.style.display = 'none'; propertyProfilerUI.style.display = 'block'; elementSleuthUI.style.display = 'none'; d3AtomModelContainer.style.display = 'none'; atomDiagramPlaceholder.style.display = 'block'; atomDiagramPlaceholder.textContent = `Focus on the properties of ${currentChallengeElementData.name}.`; atomDiagramTitle.textContent = "Element Properties"; hintExplanationArea.style.display = 'none'; displayElementInfo(currentChallengeElementData, false); const questionTypes = ['category', 'group', 'period', 'valenceElectrons', 'standardState']; const availableQuestionTypes = questionTypes.filter(type => { if (type === 'valenceElectrons' && typeof currentChallengeElementData.valenceElectrons === 'undefined') return false; if (type === 'standardState' && typeof currentChallengeElementData.standardState === 'undefined') return false; return true; }); if (availableQuestionTypes.length === 0) { console.error("No available property question types for element:", currentChallengeElementData.name); gameInstructionsP.textContent = `No property questions available for ${currentChallengeElementData.name}. Skipping.`; loadNextChallengeQuestion(); return; } const randomQuestionType = availableQuestionTypes[Math.floor(Math.random() * availableQuestionTypes.length)]; currentQuestionDetails.type = randomQuestionType; let questionText = ""; let correctAnswerValue; if (randomQuestionType === 'category') { questionText = `What is the category of ${currentChallengeElementData.name} (${currentChallengeElementData.symbol})?`; correctAnswerValue = currentChallengeElementData.category; currentQuestionDetails.correctAnswerDisplay = elementCategories[correctAnswerValue]?.name || correctAnswerValue; } else if (randomQuestionType === 'group') { questionText = `Which group is ${currentChallengeElementData.name} (${currentChallengeElementData.symbol}) in?`; correctAnswerValue = currentChallengeElementData.group; currentQuestionDetails.correctAnswerDisplay = `Group ${correctAnswerValue}`; } else if (randomQuestionType === 'period') { questionText = `Which period is ${currentChallengeElementData.name} (${currentChallengeElementData.symbol}) in?`; correctAnswerValue = currentChallengeElementData.period; currentQuestionDetails.correctAnswerDisplay = `Period ${correctAnswerValue}`; } else if (randomQuestionType === 'valenceElectrons') { questionText = `How many valence electrons does a neutral atom of ${currentChallengeElementData.name} (${currentChallengeElementData.symbol}) have?`; correctAnswerValue = currentChallengeElementData.valenceElectrons; currentQuestionDetails.correctAnswerDisplay = `${correctAnswerValue} valence electron(s)`; } else if (randomQuestionType === 'standardState') { questionText = `What is the standard physical state of ${currentChallengeElementData.name} (${currentChallengeElementData.symbol})?`; correctAnswerValue = currentChallengeElementData.standardState; currentQuestionDetails.correctAnswerDisplay = correctAnswerValue; } currentQuestionDetails.correctAnswerValue = correctAnswerValue.toString(); currentQuestionDetails.options = generateMCQOptions(correctAnswerValue, randomQuestionType, currentChallengeElementData); propertyQuestionText.textContent = questionText; mcqOptionsContainer.innerHTML = ''; selectedMCQAnswer = null; currentQuestionDetails.options.forEach(option => { const btn = document.createElement('button'); btn.classList.add('mcq-option-btn'); btn.textContent = option.text; btn.dataset.value = option.value; btn.addEventListener('click', () => { if (questionAnswered || btn.disabled) return; const currentlySelected = mcqOptionsContainer.querySelector('.selected-answer'); if (currentlySelected) { currentlySelected.classList.remove('selected-answer'); } btn.classList.add('selected-answer'); selectedMCQAnswer = btn.dataset.value; }); mcqOptionsContainer.appendChild(btn); }); gameInstructionsP.textContent = `Select the correct property for ${currentChallengeElementData.name}.`; gameActionContainer.style.display = 'block'; checkAnswerBtn.style.display = 'block'; }

// --- ELEMENT SLEUTH FUNCTIONS ---
function filterPeriodicTableForSleuth() {
    const allElementSquares = periodicTableContainer.querySelectorAll('.element-square');
    allElementSquares.forEach(square => {
        const atomicNumberStr = square.dataset.atomicNumber;
        if (!atomicNumberStr) return;
        const atomicNumber = parseInt(atomicNumberStr);
        const element = elementsData.find(el => el.atomicNumber === atomicNumber);
        if (!element) return;

        let matchesAllClues = true;
        for (const clue of revealedCluesSleuth) {
            if (clue.type === 'period' && element.period !== clue.value) matchesAllClues = false;
            else if (clue.type === 'group' && element.group !== clue.value) matchesAllClues = false;
            else if (clue.type === 'category' && element.category !== clue.value) matchesAllClues = false;
            else if (clue.type === 'standardState' && element.standardState !== clue.value) matchesAllClues = false;
            else if (clue.type === 'valenceElectrons' && element.valenceElectrons !== clue.value) matchesAllClues = false;
            else if (clue.type === 'atomicNumberRange' && (element.atomicNumber < clue.value.min || element.atomicNumber > clue.value.max)) matchesAllClues = false;
            // Add more clue type checks here as they are developed
            if (!matchesAllClues) break;
        }

        if (matchesAllClues) {
            square.classList.remove('eliminated-element');
        } else {
            square.classList.add('eliminated-element');
        }
    });
}

function generateCluesForElement(element) { if (!element) return []; let clues = []; if (element.period) clues.push({ type: 'period', value: element.period, text: `I am in Period ${element.period}.` }); if (element.group) { let groupText = `I am in Group ${element.group}`; if (element.category === "alkali-metal") groupText += " (Alkali Metals)."; else if (element.category === "alkaline-earth-metal") groupText += " (Alkaline Earth Metals)."; else if (element.category === "halogen") groupText += " (Halogens)."; else if (element.category === "noble-gas") groupText += " (Noble Gases)."; else groupText += "."; clues.push({ type: 'group', value: element.group, text: groupText }); } if (element.category && elementCategories[element.category]) { clues.push({ type: 'category', value: element.category, text: `My category is ${elementCategories[element.category].name}.` }); } if (element.standardState) { clues.push({ type: 'standardState', value: element.standardState, text: `I am a ${element.standardState.toLowerCase()} at standard conditions.`}); } if (typeof element.valenceElectrons !== 'undefined' && (element.group === 1 || element.group === 2 || (element.group >= 13 && element.group <= 18))) { clues.push({ type: 'valenceElectrons', value: element.valenceElectrons, text: `I have ${element.valenceElectrons} valence electron(s).`}); } const lowerBound = Math.max(1, element.atomicNumber - 5); const upperBound = element.atomicNumber + 5; clues.push({type: 'atomicNumberRange', value: {min: lowerBound, max: upperBound}, text: `My atomic number is between ${lowerBound} and ${upperBound} (inclusive).`}); return clues.sort(() => 0.5 - Math.random()); }
function revealNextClueSleuth() { if (currentClueIndexSleuth < potentialCluesSleuth.length && revealedCluesSleuth.length < MAX_CLUES_SLEUTH) { const nextClueObject = potentialCluesSleuth[currentClueIndexSleuth]; revealedCluesSleuth.push(nextClueObject); const clueListItem = document.createElement('li'); clueListItem.textContent = nextClueObject.text; if (revealedCluesSleuth.length > 1 || clueListUl.children.length > 0) { clueListItem.style.opacity = 0; setTimeout(() => { clueListItem.style.animation = 'fadeInClue 0.5s ease-out forwards'; }, 50 * revealedCluesSleuth.length ); } else { clueListItem.style.opacity = 1; } clueListUl.appendChild(clueListItem); currentClueIndexSleuth++; clueCountCurrentSpan.textContent = revealedCluesSleuth.length; filterPeriodicTableForSleuth(); } if (revealedCluesSleuth.length >= MAX_CLUES_SLEUTH || currentClueIndexSleuth >= potentialCluesSleuth.length) { revealNextClueBtn.disabled = true; revealNextClueBtn.style.display = 'none'; gameInstructionsP.textContent = "All clues revealed! Make your final guess."; } else { revealNextClueBtn.disabled = false; } }
function setupElementSleuthChallenge() { currentChallengeTitle.textContent = "Element Sleuth Challenge"; particlePinpointUI.style.display = 'none'; propertyProfilerUI.style.display = 'none'; elementSleuthUI.style.display = 'block'; d3AtomModelContainer.style.display = 'none'; atomDiagramPlaceholder.style.display = 'block'; atomDiagramPlaceholder.textContent = "The Periodic Table below is your guessing board!"; atomDiagramTitle.textContent = "Periodic Table - Guessing Board"; hintExplanationArea.style.display = 'none'; gameActionContainer.style.display = 'block'; checkAnswerBtn.style.display = 'none'; revealNextClueBtn.style.display = 'block'; revealNextClueBtn.disabled = true; targetElementSleuth = selectRandomElementForChallenge(); if (!targetElementSleuth) { gameInstructionsP.textContent = "Error starting Element Sleuth. Could not select a target element."; return; } console.log("Target Sleuth Element:", targetElementSleuth.name); potentialCluesSleuth = generateCluesForElement(targetElementSleuth); if (potentialCluesSleuth.length === 0) { console.error("No clues generated for target element:", targetElementSleuth.name); gameInstructionsP.textContent = "Error: Not enough information to generate clues for this element. Try another round."; startChallengeBtn.disabled = false; startChallengeBtn.textContent = "Try New Sleuth Round"; return; } revealedCluesSleuth = []; currentClueIndexSleuth = 0; clueListUl.innerHTML = ''; sleuthGuessesRemaining = MAX_GUESSES_SLEUTH_ROUND; questionAnswered = false; clueCountTotalSpan.textContent = Math.min(MAX_CLUES_SLEUTH, potentialCluesSleuth.length); updateGameStatusDisplay(); filterPeriodicTableForSleuth(); // Initial filter (will show all as no clues revealed yet) revealNextClueSleuth(); displayElementInfo(null, false); elementInfoTitle.textContent = "Mystery Element Profile"; elementDetailsContainer.innerHTML = "<p>Click on the periodic table to make your guess after reviewing the clue(s).</p>"; periodicTableContainer.classList.add('element-sleuth-active'); gameInstructionsP.textContent = "A new mystery element is chosen! Review the clue."; }
function checkElementSleuthGuess(guessedElementData) { if (!gameActive || questionAnswered || !targetElementSleuth) return; sleuthGuessesRemaining--; updateGameStatusDisplay(); if (guessedElementData.atomicNumber === targetElementSleuth.atomicNumber) { score += (MAX_CLUES_SLEUTH - revealedCluesSleuth.length + 1) * 5; feedbackMessageDiv.textContent = `Amazing! You found ${targetElementSleuth.name}! You earned points based on clues used.`; feedbackMessageDiv.className = 'feedback-message feedback-success'; questionAnswered = true; correctAnswersThisSession++; } else { if (sleuthGuessesRemaining <= 0) { feedbackMessageDiv.textContent = `Out of guesses! The mystery element was ${targetElementSleuth.name}.`; feedbackMessageDiv.className = 'feedback-message feedback-error'; questionAnswered = true; } else { feedbackMessageDiv.textContent = `Not ${guessedElementData.name}. That's not the one. Try another guess or get more clues. ${sleuthGuessesRemaining} guesses left.`; feedbackMessageDiv.className = 'feedback-message feedback-warning'; revealNextClueBtn.disabled = (revealedCluesSleuth.length >= MAX_CLUES_SLEUTH); } } feedbackMessageDiv.style.display = 'block'; if (questionAnswered) { displayElementInfo(targetElementSleuth, true); revealNextClueBtn.style.display = 'none'; startChallengeBtn.textContent = "Next Question"; startChallengeBtn.disabled = false; periodicTableContainer.classList.remove('element-sleuth-active'); document.querySelectorAll('.element-square.eliminated-element').forEach(sq => sq.classList.remove('eliminated-element')); if (questionsPlayedThisSession >= MAX_QUESTIONS_PER_SESSION) { showSessionSummary(); } else { startChallengeBtn.textContent = "Next Sleuth Round"; } } }
function showSessionSummary() { gameActive = false; particlePinpointUI.style.display = 'none'; propertyProfilerUI.style.display = 'none'; elementSleuthUI.style.display = 'none'; gameControlsContainer.style.display = 'none'; gameActionContainer.style.display = 'none'; d3AtomModelContainer.style.display = 'none'; atomDiagramPlaceholder.style.display = 'block'; atomDiagramPlaceholder.textContent = "Challenge complete! See summary below."; elementInfoContainer.style.display = 'none'; hintExplanationArea.style.display = 'none'; sessionSummaryContainer.style.display = 'block'; summaryScoreSpan.textContent = score; summaryCorrectSpan.textContent = correctAnswersThisSession; summaryTotalPlayedSpan.textContent = questionsPlayedThisSession; const accuracy = questionsPlayedThisSession > 0 ? ((correctAnswersThisSession / questionsPlayedThisSession) * 100).toFixed(1) : 0; summaryAccuracySpan.textContent = `${accuracy}%`; periodicTableContainer.classList.remove('periodic-table-disabled', 'element-sleuth-active'); document.querySelectorAll('.element-square.eliminated-element').forEach(sq => sq.classList.remove('eliminated-element')); updateZoneHighlighting(); }
function loadNextChallengeQuestion() { questionAnswered = false; selectedMCQAnswer = null; if (currentGameMode !== 'element-sleuth') { checkAnswerBtn.disabled = false; } startChallengeBtn.disabled = true; startChallengeBtn.classList.add("next-element-btn"); hintExplanationArea.style.display = 'none'; questionsPlayedThisSession++; currentChallengeElementData = selectRandomElementForChallenge(); if (!currentChallengeElementData) { gameInstructionsP.textContent = "Error: Could not load an element. Try a different zone or check console."; if(checkAnswerBtn) checkAnswerBtn.disabled = true; startChallengeBtn.disabled = true; gameActive = false; return; } attemptsForCurrentQuestion = 0; updateGameStatusDisplay(); feedbackMessageDiv.textContent = ''; feedbackMessageDiv.className = 'feedback-message'; feedbackMessageDiv.style.display = 'none'; if (currentGameMode === 'particle-pinpoint') { setupParticlePinpointChallenge(); startChallengeBtn.textContent = "Next Element"; } else if (currentGameMode === 'property-profiler') { setupPropertyProfilerChallenge(); startChallengeBtn.textContent = "Next Question"; } else if (currentGameMode === 'element-sleuth') { setupElementSleuthChallenge(); startChallengeBtn.textContent = "Next Sleuth Round"; } }
function handleGameModeSelection(mode) { currentGameMode = mode; gameActive = false; questionsPlayedThisSession = 0; correctAnswersThisSession = 0; document.querySelectorAll('.game-mode-select-btn').forEach(btn => btn.classList.remove('active-mode')); if (mode === 'particle-pinpoint') particlePinpointSelectBtn.classList.add('active-mode'); if (mode === 'property-profiler') propertyProfilerSelectBtn.classList.add('active-mode'); if (mode === 'element-sleuth') elementSleuthSelectBtn.classList.add('active-mode'); gameControlsContainer.style.display = 'block'; if (mode === 'element-sleuth') { currentChallengeTitle.textContent = "Element Sleuth"; gameInstructionsP.textContent = `Ready to start the Element Sleuth challenge in the '${gameZones[currentZoneKey].name}' zone?`; } else { currentChallengeTitle.textContent = mode === 'particle-pinpoint' ? "Particle Pinpoint" : "Property Profiler"; gameInstructionsP.textContent = `Ready to start the ${currentChallengeTitle.textContent} challenge in the '${gameZones[currentZoneKey].name}' zone?`; } startChallengeBtn.textContent = "Start Challenge"; startChallengeBtn.classList.remove("next-element-btn"); startChallengeBtn.disabled = false; particlePinpointUI.style.display = 'none'; propertyProfilerUI.style.display = 'none'; elementSleuthUI.style.display = 'none'; gameActionContainer.style.display = 'none'; sessionSummaryContainer.style.display = 'none'; d3AtomModelContainer.style.display = 'none'; atomDiagramPlaceholder.style.display = 'block'; atomDiagramPlaceholder.textContent = "Game area will appear when challenge starts."; elementInfoContainer.style.display = 'block'; elementInfoTitle.textContent = "Element Information"; elementDetailsContainer.innerHTML = "<p>Element details will appear here.</p>"; hintExplanationArea.style.display = 'none'; periodicTableContainer.classList.remove('periodic-table-disabled', 'element-sleuth-active'); document.querySelectorAll('.element-square.eliminated-element').forEach(sq => sq.classList.remove('eliminated-element')); updateZoneHighlighting(); }
function showHint() { const propertyType = currentQuestionDetails.type; if (learningContent.properties && learningContent.properties[propertyType]) { const content = learningContent.properties[propertyType]; hintExplanationText.innerHTML = `<strong>Definition:</strong> ${content.definition}<br><br><strong>Hint:</strong> ${content.hint}`; hintExplanationArea.style.display = 'block'; } else { hintExplanationText.textContent = learningContent.general?.tryAgainHint || "Try to think about the element's general characteristics."; hintExplanationArea.style.display = 'block'; } }
function checkSelectedAnswer() { if (!gameActive || questionAnswered) { feedbackMessageDiv.textContent = "Start a new challenge or click 'Next Question'."; feedbackMessageDiv.className = 'feedback-message feedback-error'; feedbackMessageDiv.style.display = 'block'; return; } attemptsForCurrentQuestion++; let isCorrect = false; if (currentGameMode === 'particle-pinpoint') { const studentProtons = parseInt(protonInput.value, 10); const studentNeutrons = parseInt(neutronInput.value, 10); const studentElectrons = parseInt(electronInput.value, 10); const correctParticles = calculateSubatomicParticles(currentChallengeElementData); [protonInput, neutronInput, electronInput].forEach(input => input.classList.remove('input-error', 'input-correct')); if (isNaN(studentProtons) || isNaN(studentNeutrons) || isNaN(studentElectrons)) { feedbackMessageDiv.textContent = "Please enter valid numbers for all fields."; feedbackMessageDiv.className = 'feedback-message feedback-error'; if (isNaN(studentProtons)) protonInput.classList.add('input-error'); if (isNaN(studentNeutrons)) neutronInput.classList.add('input-error'); if (isNaN(studentElectrons)) electronInput.classList.add('input-error'); isCorrect = false; } else { let pCorrect = studentProtons === correctParticles.protons; let nCorrect = studentNeutrons === correctParticles.neutrons; let eCorrect = studentElectrons === correctParticles.electrons; if (pCorrect) protonInput.classList.add('input-correct'); else protonInput.classList.add('input-error'); if (nCorrect) neutronInput.classList.add('input-correct'); else neutronInput.classList.add('input-error'); if (eCorrect) electronInput.classList.add('input-correct'); else electronInput.classList.add('input-error'); isCorrect = pCorrect && nCorrect && eCorrect; } } else if (currentGameMode === 'property-profiler') { if (!selectedMCQAnswer) { feedbackMessageDiv.textContent = "Please select an answer."; feedbackMessageDiv.className = 'feedback-message feedback-error'; isCorrect = false; attemptsForCurrentQuestion--; } else { isCorrect = selectedMCQAnswer === currentQuestionDetails.correctAnswerValue; } } if (isCorrect) { score += POINTS_PER_CORRECT_ANSWER; correctAnswersThisSession++; feedbackMessageDiv.textContent = `Excellent! That's correct for ${currentChallengeElementData.name}! You earned ${POINTS_PER_CORRECT_ANSWER} points.`; feedbackMessageDiv.className = 'feedback-message feedback-success'; questionAnswered = true; hintExplanationArea.style.display = 'none'; } else { if (attemptsForCurrentQuestion >= MAX_ATTEMPTS_PER_QUESTION) { questionAnswered = true; hintExplanationArea.style.display = 'none'; let revealText = `Maximum attempts reached. `; if (currentGameMode === 'particle-pinpoint') { const cp = calculateSubatomicParticles(currentChallengeElementData); revealText += `The correct counts for ${currentChallengeElementData.name} were P: ${cp.protons}, N: ${cp.neutrons}, E: ${cp.electrons}.`; } else if (currentGameMode === 'property-profiler') { revealText += `The correct ${currentQuestionDetails.type} for ${currentChallengeElementData.name} is ${currentQuestionDetails.correctAnswerDisplay}.`; } feedbackMessageDiv.textContent = revealText; feedbackMessageDiv.className = 'feedback-message feedback-error'; } else { feedbackMessageDiv.textContent = `Not quite right. (${MAX_ATTEMPTS_PER_QUESTION - attemptsForCurrentQuestion} attempts left)`; feedbackMessageDiv.className = 'feedback-message feedback-warning'; if (currentGameMode === 'property-profiler') { if (attemptsForCurrentQuestion === 1) { showHint(); feedbackMessageDiv.textContent += " Review the hint and try again!"; } else if (hintExplanationArea.style.display === 'block') { feedbackMessageDiv.textContent += " Try again!"; } mcqOptionsContainer.querySelectorAll('.mcq-option-btn').forEach(btn => { btn.disabled = false; btn.classList.remove('selected-answer', 'incorrect-answer', 'correct-answer'); }); selectedMCQAnswer = null; } } } updateGameStatusDisplay(); feedbackMessageDiv.style.display = 'block'; if (questionAnswered) { displayElementInfo(currentChallengeElementData, true); if (currentGameMode !== 'element-sleuth') { checkAnswerBtn.disabled = true; } startChallengeBtn.disabled = false; if (questionsPlayedThisSession >= MAX_QUESTIONS_PER_SESSION) { showSessionSummary(); } else { startChallengeBtn.textContent = "Next Question"; gameInstructionsP.textContent = "Click 'Next Question' for a new challenge!"; } if (currentGameMode === 'particle-pinpoint') { [protonInput, neutronInput, electronInput].forEach(input => { if (input) input.disabled = true; }); } else if (currentGameMode === 'property-profiler') { mcqOptionsContainer.querySelectorAll('.mcq-option-btn').forEach(btn => { btn.disabled = true; if (btn.dataset.value === currentQuestionDetails.correctAnswerValue) { btn.classList.remove('incorrect-answer', 'selected-answer'); btn.classList.add('correct-answer'); } else if (btn.dataset.value === selectedMCQAnswer && !isCorrect) { btn.classList.add('incorrect-answer'); } }); } } }
function isElementInCurrentZone(elementData) { if (!currentZoneKey || !gameZones[currentZoneKey]) return false; const zone = gameZones[currentZoneKey]; if (zone.elementAtomicNumbers === null) return true; if (zone.elementAtomicNumbers && zone.elementAtomicNumbers.includes(elementData.atomicNumber)) return true; if (zone.categories && zone.categories.includes(elementData.category)) return true; if (zone.customFilter && typeof zone.customFilter === 'function' && zone.customFilter(elementData)) return true; return false; }
function updateZoneHighlighting() { const allElementSquares = periodicTableContainer.querySelectorAll('.element-square'); allElementSquares.forEach(square => { const atomicNumberStr = square.dataset.atomicNumber; if (!atomicNumberStr) return; const atomicNumber = parseInt(atomicNumberStr); const elementData = elementsData.find(el => el.atomicNumber === atomicNumber); if (elementData) { square.classList.remove('highlight-zone-element', 'dim-non-zone-element', 'eliminated-element'); if (isZoneHighlightingActive) { if (isElementInCurrentZone(elementData)) { square.classList.add('highlight-zone-element'); } else { square.classList.add('dim-non-zone-element'); } } } }); }
function populateZoneSelection() { zoneButtonsContainer.innerHTML = ''; Object.keys(gameZones).forEach(zoneKey => { const zone = gameZones[zoneKey]; const button = document.createElement('button'); button.classList.add('zone-select-btn'); button.textContent = zone.name; button.dataset.zoneKey = zoneKey; if (zoneKey === currentZoneKey) { button.classList.add('active-zone'); } button.addEventListener('click', () => handleZoneSelection(zoneKey)); zoneButtonsContainer.appendChild(button); }); updateGameStatusDisplay(); updateZoneHighlighting(); }
function handleZoneSelection(selectedZoneKey) { if (gameActive) { feedbackMessageDiv.textContent = "Cannot change zone during an active challenge. Finish or reset the challenge first."; feedbackMessageDiv.className = 'feedback-message feedback-warning'; feedbackMessageDiv.style.display = 'block'; setTimeout(() => { feedbackMessageDiv.style.display = 'none'; }, 3000); return; } currentZoneKey = selectedZoneKey; document.querySelectorAll('.zone-select-btn').forEach(btn => { btn.classList.remove('active-zone'); if (btn.dataset.zoneKey === selectedZoneKey) { btn.classList.add('active-zone'); } }); updateGameStatusDisplay(); updateZoneHighlighting(); if(currentGameMode) { gameInstructionsP.textContent = `Ready to start the ${currentChallengeTitle.textContent} challenge in the '${gameZones[currentZoneKey].name}' zone?`; } }
function initializeAppView() { populateZoneSelection(); updateGameStatusDisplay(); particlePinpointUI.style.display = 'none'; propertyProfilerUI.style.display = 'none'; elementSleuthUI.style.display = 'none'; gameActionContainer.style.display = 'none'; gameControlsContainer.style.display = 'none'; sessionSummaryContainer.style.display = 'none'; d3AtomModelContainer.style.display = 'none'; atomDiagramPlaceholder.style.display = 'block'; atomDiagramPlaceholder.textContent = "Select your zone and challenge mode to begin!"; elementInfoContainer.style.display = 'block'; elementInfoTitle.textContent = "Element Information"; elementDetailsContainer.innerHTML = "<p>Element details will appear here.</p>"; periodicTableContainer.classList.remove('periodic-table-disabled', 'element-sleuth-active'); hintExplanationArea.style.display = 'none'; if(zoneHighlightToggle) zoneHighlightToggle.checked = isZoneHighlightingActive; gameSelectionContainer.style.display = 'block'; }
async function loadLearningContent() { try { const response = await fetch('assets/data/learning_content.json'); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } learningContent = await response.json(); console.log("Learning content loaded successfully:", learningContent); } catch (error) { console.error("Could not load learning content:", error); learningContent = { properties: {}, general: { tryAgainHint: "Something went wrong loading hints. Please try your best!"} }; } }
function displayPeriodicTableElements() { periodicTableContainer.innerHTML = ""; elementsData.forEach(elementDataFromLoop => { const elementSquare = document.createElement("div"); elementSquare.classList.add("element-square"); elementSquare.classList.add(elementDataFromLoop.category || "unknown"); elementSquare.style.gridColumnStart = elementDataFromLoop.group; elementSquare.style.gridRowStart = elementDataFromLoop.period; elementSquare.dataset.atomicNumber = elementDataFromLoop.atomicNumber; const atomicNumberDisplay = document.createElement("div"); atomicNumberDisplay.classList.add("atomic-number"); atomicNumberDisplay.textContent = elementDataFromLoop.atomicNumber; const symbolDisplay = document.createElement("div"); symbolDisplay.classList.add("symbol"); symbolDisplay.textContent = elementDataFromLoop.symbol; elementSquare.appendChild(atomicNumberDisplay); elementSquare.appendChild(symbolDisplay); elementSquare.addEventListener('click', () => { if (gameActive && currentGameMode === 'element-sleuth' && !questionAnswered) { const guessedAtomicNumber = parseInt(elementSquare.dataset.atomicNumber); const guessedElement = elementsData.find(el => el.atomicNumber === guessedAtomicNumber); if (guessedElement && !elementSquare.classList.contains('eliminated-element')) { checkElementSleuthGuess(guessedElement); } } else if (gameActive) { return; } }); periodicTableContainer.appendChild(elementSquare); }); updateZoneHighlighting(); }
function displayLegend() { legendContentDiv.innerHTML = ""; for (const categoryKey in elementCategories) { const category = elementCategories[categoryKey]; const legendItem = document.createElement("div"); legendItem.classList.add("legend-item"); const colorBox = document.createElement("div"); colorBox.classList.add("legend-color-box"); colorBox.style.backgroundColor = category.color; const text = document.createElement("span"); text.classList.add("legend-text"); text.textContent = category.name; legendItem.appendChild(colorBox); legendItem.appendChild(text); legendContentDiv.appendChild(legendItem); } }


loadNextChallengeQuestion();
// Correctly closes the arrow function for the event listener
} // Correctly closes the if (startChallengeBtn) block